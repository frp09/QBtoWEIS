"""

Copyright Â© 2024 Robert Behrens de Luna. All rights reserved.

This software project and all associated files are protected by copyright and may not
be copied, distributed, or modified without the express written permission of the 
copyright holder.

A significant portion of this project relies on code from the WISDEM/WEIS repository (https://github.com/WISDEM/WEIS),
which is licensed under the Apache 2.0 License. The terms of the Apache 2.0 License apply to those parts and can be
found in the LICENSE file. The remainder of the code, as indicated by this copyright notice, is protected by copyright
and may not be used without authorization.

"""

from ctypes import *
from QBladeLibrary import QBladeLibrary
import sys
import concurrent.futures
import shutil
import stat
import time
import os
import numpy as np
import pandas as pd
import struct as st

def qblade_sil(QBlade_dll, QBLADE_runDirectory, sim, channels, store_qprs, out_file_format):
    
    temp_qblade_so = make_temp_qblade_so_copy(QBlade_dll)
    
    # Set up the library path so the subprocess can find dependencies
    if sys.platform == "linux":
        lib_dir = os.path.join(os.path.dirname(QBlade_dll), "Libraries")
        ld_path = os.environ.get("LD_LIBRARY_PATH", "")
        os.environ["LD_LIBRARY_PATH"] = f"{lib_dir}:{ld_path}"

        # Try to manually load all shared libraries from that directory
        for filename in os.listdir(lib_dir):
            if filename.endswith(".so") or ".so." in filename:
                try:
                    lib_path = os.path.join(lib_dir, filename)
                    CDLL(lib_path, mode=RTLD_GLOBAL)
                except Exception as e:
                    print(f"Failed to preload {filename}: {e}")

    try:
        bsim = sim.encode("utf-8")
        sim_name = os.path.basename(sim)
        QBLIB = QBladeLibrary(temp_qblade_so)
        QBLIB.createInstance(1,32) 
        QBLIB.setOmpNumThreads(1)
        QBLIB.loadSimDefinition(bsim)
        QBLIB.initializeSimulation()
        QBLIB.setAutoClearTemp(False)

        QBLIB.runFullSimulation()

        sim_out_name = sim_name.strip('.sim')
        
        # TODO: allow for out AND oub
        if out_file_format == 2: # 2 --> binary:
            QBLIB.exportResults(3, QBLADE_runDirectory.encode(), (sim_out_name + '_completed').encode(), channels.encode()) # this is required to get the time channel
        else:
            raise ValueError("Error: Only 'outb' format is supported for binary export (out_file_format = 2). 'out' is no longer supported.")
            
        if 'True' in store_qprs:
            output_file = f"{sim_out_name}_completed.qpr".encode('ASCII')
            QBLIB.storeProject(output_file)
        
        QBLIB.closeInstance()
        del QBLIB.lib
    finally:
        try:
            os.remove(temp_qblade_so)
        except Exception as e:
            print(f"Could not delete temp .so file: {temp_qblade_so}: {e}")

def run_qblade_sil(QBlade_dll, QBLADE_runDirectory, channels, number_of_workers, store_qprs, out_file_format):
    
    # clear_and_delete_temp(QBlade_dll) # delete TEMP folder within QBlade directory to prevent unnecessary data clogging

    simulations = [os.path.join(QBLADE_runDirectory, f) for f in os.listdir(QBLADE_runDirectory) if f.endswith('.sim')]

    with concurrent.futures.ProcessPoolExecutor(max_workers=number_of_workers) as executor:
        futures = []
        for sim in simulations:
            futures.append(
                executor.submit(qblade_sil, QBlade_dll, QBLADE_runDirectory, sim, channels, store_qprs, out_file_format)
            )
            time.sleep(0.25)  # Optional: Add a small delay to avoid overwhelming the system
        for future in concurrent.futures.as_completed(futures):
            try:
                future.result()
            except Exception as e:
                print(f"Simulation failed after retrying with exception: {e}")

def make_temp_qblade_so_copy(original_so_path):
    """
    Create a temporary copy of the QBlade .so file in the same directory.
    """
    dir_path = os.path.dirname(original_so_path)
    base_name = os.path.basename(original_so_path)
    temp_name = f"tmp_{os.getpid()}_{base_name}"
    temp_path = os.path.join(dir_path, temp_name)

    try:
        shutil.copy2(original_so_path, temp_path)
        if not os.path.exists(temp_path):
            raise RuntimeError(f"Temp .so not found at {temp_path}")
    except Exception as e:
        raise RuntimeError(f"Failed to copy .so file: {e}")
    
    return temp_path

def export_to_OF_Binary(data, outfilename):
    """
    Writes a results file in OpenFAST Binary format.
    
    Parameters:
    - data: A DataFrame with channel names and data. Channel names are in the format 'ChannelName [Unit]'.
    - outfilename: The path to the output binary file.
    """

    FileID = 4
    DescStr = "Generated by export_to_OF_Binary"
    PackingData = None

    channels = []
    ChanUnit = []

    for idx, entry in enumerate(data):
        split_string = entry.split(" [")
        channels.append(split_string[0])
        # channels.append(split_string[0].replace(' ','_'))
        ChanUnit.append(''.join(('(',split_string[1].strip("]"),')')))

    dataframe = pd.DataFrame(data)
    col_names = dict(zip(dataframe.columns, channels))
    Chans = dataframe.rename(col_names, axis=1)

    if 'Time' not in Chans.columns:
        raise ValueError("'Time' column is required and must be named exactly 'Time'")

    cols = Chans.columns.tolist()
    cols.insert(0, cols.pop(cols.index('Time')))  # Move 'Time' to front
    Chans = Chans[cols]
    
    # Scaling Parameters                                 
    IntMax = np.float64(32757.0)                            
    IntMin = np.float64(-32768.0)                           
    IntRang = np.float64(IntMax-IntMin)                     

    # Time parameters
    Time = np.float64(Chans.Time)                                           
    TimeOut1 = Time[0]                                      
    TimeIncrement = Time[1]-Time[0]                         

    # The Channels without time
    ChansMod = Chans.drop("Time", axis=1)
    ColMax = np.float64(ChansMod.max())                     
    ColMin = np.float64(ChansMod.min())                     
    ColOff = []                                             
    ColScl = []                                             

    LenDesc = len(DescStr)                                  
    NT = len(Time)                                          
    NumOutChans = len(ChansMod.columns)                                        

    TmpOutArray = np.zeros((ChansMod.size), dtype=np.int16)                                            
    
    maxChanLen = max(len(name) for name in channels)
    maxUnitLen = max(len(unit) for unit in ChanUnit)
    nChar = max(maxChanLen, maxUnitLen)        

    if PackingData is None:
        for i in range(len(ColMax)):
            if ColMax[i] == ColMin[i]:
                ColScl.append(np.float32(1))
            else:
                ColScl.append(np.float32(IntRang / (ColMax[i] - ColMin[i])))
            ColOff.append(np.float32(IntMin - ColScl[i] * ColMin[i]))
    else:
        ColScl = PackingData['ColScl']
        ColOff = PackingData['ColOff']                         

    TempFrame = ChansMod.copy()
    for j in range(NumOutChans):
        TempFrame[TempFrame.columns[j]] = ColScl[j] * TempFrame[TempFrame.columns[j]] + ColOff[j]
    TmpOutArray = np.clip(TempFrame.values.flatten(), IntMin, IntMax).astype(np.int16)

    ChanNameASCII = [name[:nChar].ljust(nChar).encode('latin_1') for name in Chans.columns]
    ChanUnitASCII = [unit[:nChar].ljust(nChar).encode('latin_1') for unit in ChanUnit]
    
    with open(outfilename, 'wb') as outfile:
        outfile.write(st.pack('h', np.int16(FileID)))
        outfile.write(st.pack('@h', np.int16(nChar)))
        outfile.write(st.pack('i', np.int32(NumOutChans)))
        outfile.write(st.pack('i', np.int32(NT)))

        outfile.write(st.pack('d', np.float64(TimeOut1)))
        outfile.write(st.pack('d', np.float64(TimeIncrement)))

        outfile.write(np.array(ColScl, dtype=np.float32))
        outfile.write(np.array(ColOff, dtype=np.float32))

        outfile.write(np.int32(LenDesc))
        outfile.write(DescStr.encode('utf-8'))

        

        outfile.write(np.array(ChanNameASCII))
        outfile.write(np.array(ChanUnitASCII))

        outfile.write(TmpOutArray)

def export_to_OF_ASCII(data, directory=None, filename=None, first_chunk=True):
    """
    Writes a results file in OpenFAST ASCII format. 
    """ 
    # split channel name and unit
    channels = []
    units = []
    for idx, entry in enumerate(data):
        split_string = entry.split(" [")
        channels.append(split_string[0])
        # channels.append(split_string[0].replace(' ','_')) # This would be required to make the result file compatible with PDAP becaus blank spaces are not allowed
        units.append(''.join(('(',split_string[1].strip("]"),')')))
    dataframe = pd.DataFrame(data)

    # create dataframe with 2 headers (1. channel names, 2. units)
    dataframe = pd.DataFrame(data)
    col_names = dict(zip(dataframe.columns, channels))
    dataframe = dataframe.rename(col_names, axis=1)
    units_df = pd.DataFrame([units], columns=channels)
    dataframe = pd.concat([units_df, dataframe], ignore_index=True)

    # Apply scientific notation format with 6 decimal places
    dataframe = dataframe.apply(lambda col: col.map(lambda x: f"{x:.6E}" if isinstance(x, (int, float)) else x))

    if first_chunk:  # Write header only for the first chunk of data
        with open(filename, 'w') as f:  # Open in 'w' mode for the first chunk
            f.write('---------------------------------------- file generated with WEIS QBlade API ----------------------------------------\n')
            f.write('Results are written in OpenFAST ASCII (.out) format\n')
            f.write(os.path.basename(filename)) # write the filename
            f.write("\n \n \n \n")
            data_string = dataframe.to_csv(sep='\t', index=False, header=True, lineterminator='\n')
            f.write(data_string)

    else:  # Append data for subsequent chunks,
        with open(filename, 'a') as f:  # Open in 'a' mode to append
            data_string = dataframe.iloc[1:].to_csv(sep='\t', index=False, header=False, lineterminator='\n')  # Skip first two rows
            f.write(data_string)

def scale_and_rename_channels(output_dict):
    """
    Scale [N] -> [kN] and [Nm] -> [kNm]
    """
    for channel in list(output_dict.keys()):
        if "[N]" in channel:
            output_dict[channel] = [value * 1e-03 for value in output_dict[channel]]
            new_channel_name = channel.replace("[N]", "[kN]")
            output_dict[new_channel_name] = output_dict.pop(channel)
            
        elif "[Nm]" in channel:
            output_dict[channel] = [value * 1e-03 for value in output_dict[channel]]
            new_channel_name = channel.replace("[Nm]", "[kNm]")
            output_dict[new_channel_name] = output_dict.pop(channel)

        elif "[W]" in channel:
            output_dict[channel] = [value * 1e-03 for value in output_dict[channel]]
            new_channel_name = channel.replace("[W]", "[kW]")
            output_dict[new_channel_name] = output_dict.pop(channel)
        
    return output_dict

def handle_remove_error(func, path, exc_info):
    """Handles file/folder removal errors by adjusting permissions and retrying."""
    try:
        # Remove read-only flag (Windows) or add write permission (Linux)
        if os.name == "nt":  # Windows
            os.chmod(path, stat.S_IWRITE)
        else:  # Linux/macOS
            os.chmod(path, stat.S_IWUSR)  # User write permission

        func(path)  # Retry deletion
    except Exception as e:
        print(f"Failed to remove {path}: {e}")

def clear_and_delete_temp(qblade_dll):
    """Removes the read-only attribute, clears TEMP folder contents, and deletes it."""
    qblade_dir = os.path.dirname(qblade_dll)
    temp_path = os.path.join(qblade_dir, "TEMP")

    if os.path.exists(temp_path) and os.path.isdir(temp_path):
        try:
            # Remove all files and subdirectories first
            for root, dirs, files in os.walk(temp_path, topdown=False):
                for file in files:
                    file_path = os.path.join(root, file)
                    try:
                        os.chmod(file_path, stat.S_IWRITE)  # Remove read-only attribute
                        os.remove(file_path)  # Delete file
                    except Exception as e:
                        print(f"Failed to delete file {file_path}: {e}")
                        
                for dir in dirs:
                    dir_path = os.path.join(root, dir)
                    try:
                        os.chmod(dir_path, stat.S_IWRITE)  # Remove read-only attribute
                        os.rmdir(dir_path)  # Remove empty directory
                    except Exception as e:
                        print(f"Failed to delete directory {dir_path}: {e}")

            # Now delete the TEMP folder itself, using onexc to handle errors
            shutil.rmtree(temp_path, onexc=handle_remove_error)
            print("TEMP folder successfully deleted.")
        except Exception as e:
            print(f"Failed to delete TEMP folder: {e}")
        
if __name__ == "__main__":
    
    QBlade_dll = sys.argv[1]
    QBLADE_runDirectory = sys.argv[2]
    channels = sys.argv[3]
    number_of_workers = int(sys.argv[4])
    store_qprs = sys.argv[5]
    out_file_format =  float(sys.argv[6])

    run_qblade_sil(QBlade_dll, QBLADE_runDirectory, channels, number_of_workers, store_qprs, out_file_format)
